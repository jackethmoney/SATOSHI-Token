'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _typeof = _interopDefault(require('@babel/runtime/helpers/typeof'));
var numberToBN = _interopDefault(require('number-to-bn'));
var lodash = require('lodash');
var utf8 = _interopDefault(require('utf8'));
var randombytes = _interopDefault(require('randombytes'));
var BN = _interopDefault(require('bn.js'));
var Hash = _interopDefault(require('eth-lib/lib/hash'));
var map = _interopDefault(require('lodash/map'));
var has = _interopDefault(require('lodash/has'));

var zero = new BN(0);
var negative1 = new BN(-1);
var unitMap = {
  wei: '1',
  kwei: '1000',
  Kwei: '1000',
  mwei: '1000000',
  Mwei: '1000000',
  gwei: '1000000000',
  Gwei: '1000000000',
  ether: '1000000000000000000',
  kether: '1000000000000000000000',
  mether: '1000000000000000000000000',
  gether: '1000000000000000000000000000',
  tether: '1000000000000000000000000000000'
};
function getValueOfUnit(unitInput) {
  var unit = unitInput ? unitInput.toLowerCase() : 'ether';
  var unitValue = unitMap[unit];
  if (typeof unitValue !== 'string') {
    throw new TypeError('[rbtc-unit] the unit provided ' + unitInput + " doesn't exists, please use the one of the following units " + JSON.stringify(unitMap, null, 2));
  }
  return new BN(unitValue, 10);
}
function numberToString(argument) {
  if (typeof argument === 'string') {
    if (!argument.match(/^-?[0-9.]+$/)) {
      throw new Error("while converting number to string, invalid number value '" + argument + "', should be a number matching (^-?[0-9.]+).");
    }
    return argument;
  } else if (typeof argument === 'number') {
    return String(argument);
  } else if (_typeof(argument) === 'object' && argument.toString && (argument.toTwos || argument.dividedToIntegerBy)) {
    if (argument.toPrecision) {
      return String(argument.toPrecision());
    } else {
      return argument.toString(10);
    }
  }
  throw new Error("while converting number to string, invalid number value '" + argument + "' type " + _typeof(argument) + '.');
}
function fromWei(weiInput, unit, optionsInput) {
  var wei = numberToBN(weiInput);
  var negative = wei.lt(zero);
  var base = getValueOfUnit(unit);
  var baseLength = unitMap[unit].length - 1 || 1;
  var options = optionsInput || {};
  if (negative) {
    wei = wei.mul(negative1);
  }
  var fraction = wei.mod(base).toString(10);
  while (fraction.length < baseLength) {
    fraction = '0' + fraction;
  }
  if (!options.pad) {
    fraction = fraction.match(/^(\d*[1-9]|0)(0*)/)[1];
  }
  var whole = wei.div(base).toString(10);
  if (options.commify) {
    whole = whole.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
  }
  var value = '' + whole + (fraction === '0' ? '' : '.' + fraction);
  if (negative) {
    value = '-' + value;
  }
  return value;
}
function toWei(etherInput, unit) {
  var ether = numberToString(etherInput);
  var base = getValueOfUnit(unit);
  var baseLength = unitMap[unit].length - 1 || 1;
  var negative = ether.substring(0, 1) === '-';
  if (negative) {
    ether = ether.substring(1);
  }
  if (ether === '.') {
    throw new Error('[rbtc-unit] while converting number ' + etherInput + ' to wei, invalid value');
  }
  var comps = ether.split('.');
  if (comps.length > 2) {
    throw new Error('[rbtc-unit] while converting number ' + etherInput + ' to wei,  too many decimal points');
  }
  var whole = comps[0];
  var fraction = comps[1];
  if (!whole) {
    whole = '0';
  }
  if (!fraction) {
    fraction = '0';
  }
  if (fraction.length > baseLength) {
    throw new Error('[rbtc-unit] while converting number ' + etherInput + ' to wei, too many decimal places');
  }
  while (fraction.length < baseLength) {
    fraction += '0';
  }
  whole = new BN(whole);
  fraction = new BN(fraction);
  var wei = whole.mul(base).add(fraction);
  if (negative) {
    wei = wei.mul(negative1);
  }
  return new BN(wei.toString(10), 10);
}

function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var unitMap$1 = unitMap;
var randomHex = function randomHex(size) {
  if (!lodash.isNumber(size)) {
    throw new Error('size parameter should be a number.');
  }
  return '0x' + randombytes(size).toString('hex');
};
var jsonInterfaceMethodToString = function jsonInterfaceMethodToString(json) {
  if (!lodash.isObject(json)) {
    throw new Error('json parameter should be an object.');
  }
  if (json.name && json.name.includes('(')) {
    return json.name;
  }
  return "".concat(json.name, "(").concat(_flattenTypes(false, json.inputs).join(','), ")");
};
var _flattenTypes = function _flattenTypes(includeTuple, puts) {
  if (!lodash.isBoolean(includeTuple)) {
    throw new Error('includeTuple parameter should be a boolean.');
  }
  if (!lodash.isObject(puts)) {
    throw new Error('puts parameter should be an object.');
  }
  var types = [];
  puts.forEach(function (param) {
    if (_typeof(param.components) === 'object') {
      if (param.type.substring(0, 5) !== 'tuple') {
        throw new Error('components found but type is not tuple; report on GitHub');
      }
      var suffix = '';
      var arrayBracket = param.type.indexOf('[');
      if (arrayBracket >= 0) {
        suffix = param.type.substring(arrayBracket);
      }
      var result = _flattenTypes(includeTuple, param.components);
      if (lodash.isArray(result) && includeTuple) {
        types.push("tuple(".concat(result.join(','), ")").concat(suffix));
      } else if (!includeTuple) {
        types.push("(".concat(result.join(','), ")").concat(suffix));
      } else {
        types.push("(".concat(result, ")"));
      }
    } else {
      types.push(param.type);
    }
  });
  return types;
};
var isBN = function isBN(object) {
  return BN.isBN(object);
};
var KECCAK256_NULL_S = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
var keccak256 = function keccak256(value) {
  if (!lodash.isString(value) && !lodash.isNumber(value)) {
    throw new Error('value parameter should be a number or string.');
  }
  if (isHexStrict(value) && /^0x/i.test(value.toString())) {
    value = hexToBytes(value);
  }
  var returnValue = Hash.keccak256(value);
  if (returnValue === KECCAK256_NULL_S) {
    return null;
  } else {
    return returnValue;
  }
};
keccak256._Hash = Hash;
var toBN = function toBN(number) {
  if (!lodash.isString(number) && !lodash.isNumber(number) && !isBN(number)) {
    throw new Error('number parameter should be a string, number or BigNumber object.');
  }
  try {
    return numberToBN(number);
  } catch (error) {
    throw new Error("".concat(error, " Given value: \"").concat(number, "\""));
  }
};
var isHex = function isHex(hex) {
  return (lodash.isString(hex) || lodash.isNumber(hex)) && /^(-0x|0x)?[0-9a-f]*$/i.test(hex);
};
var isHexStrict = function isHexStrict(hex) {
  return (lodash.isString(hex) || lodash.isNumber(hex)) && /^(-)?0x[0-9a-f]*$/i.test(hex);
};
var isAddress = function isAddress(address) {
  var chainId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
    return false;
  } else if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {
    return true;
  } else {
    return checkAddressChecksum(address, chainId);
  }
};
function toChecksumAddress(address) {
  var chainId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!lodash.isString(address)) {
    throw new Error('address parameter should be a string.');
  }
  if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) throw new Error("Given address \"".concat(address, "\" is not a valid Ethereum address."));
  var stripAddress = stripHexPrefix(address).toLowerCase();
  var prefix = chainId != null ? chainId.toString() + '0x' : '';
  var keccakHash = Hash.keccak256(prefix + stripAddress).toString('hex').replace(/^0x/i, '');
  var checksumAddress = '0x';
  for (var i = 0; i < stripAddress.length; i++) {
    checksumAddress += parseInt(keccakHash[i], 16) >= 8 ? stripAddress[i].toUpperCase() : stripAddress[i];
  }
  return checksumAddress;
}
var stripHexPrefix = function stripHexPrefix(string) {
  if (!lodash.isString(string)) {
    throw new Error('string parameter should be a string.');
  }
  return string.startsWith('0x') || string.startsWith('0X') ? string.slice(2) : string;
};
var checkAddressChecksum = function checkAddressChecksum(address) {
  var chainId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!lodash.isString(address)) {
    throw new Error('address parameter needs to be a string.');
  }
  var stripAddress = stripHexPrefix(address).toLowerCase();
  var prefix = chainId != null ? chainId.toString() + '0x' : '';
  var keccakHash = Hash.keccak256(prefix + stripAddress).toString('hex').replace(/^0x/i, '');
  for (var i = 0; i < stripAddress.length; i++) {
    var output = parseInt(keccakHash[i], 16) >= 8 ? stripAddress[i].toUpperCase() : stripAddress[i];
    if (stripHexPrefix(address)[i] !== output) {
      return false;
    }
  }
  return true;
};
var toHex = function toHex(value, returnType) {
  if (isAddress(value)) {
    return returnType ? 'address' : "0x".concat(value.toLowerCase().replace(/^0x/i, ''));
  }
  if (lodash.isBoolean(value)) {
    return returnType ? 'bool' : value ? '0x01' : '0x00';
  }
  if (lodash.isObject(value) && !isBN(value)) {
    return returnType ? 'string' : utf8ToHex(JSON.stringify(value));
  }
  if (lodash.isString(value)) {
    if (value.indexOf('-0x') === 0 || value.indexOf('-0X') === 0) {
      return returnType ? 'int256' : numberToHex(value);
    } else if (value.indexOf('0x') === 0 || value.indexOf('0X') === 0) {
      return returnType ? 'bytes' : value;
    } else if (!isFinite(value)) {
      return returnType ? 'string' : utf8ToHex(value);
    }
  }
  return returnType ? value < 0 ? 'int256' : 'uint256' : numberToHex(value);
};
var hexToNumberString = function hexToNumberString(value) {
  if (!lodash.isString(value) && !lodash.isNumber(value) && !isBN(value)) {
    throw new Error('value parameter should be a string, number or BigNumber object.');
  }
  if (lodash.isString(value)) {
    if (!isHexStrict(value)) throw new Error("Given value \"".concat(value, "\" is not a valid hex string."));
  }
  return toBN(value).toString(10);
};
var hexToNumber = function hexToNumber(value) {
  if (!lodash.isString(value) && !lodash.isNumber(value) && !isBN(value)) {
    throw new Error('value parameter should be a string, number or BigNumber object.');
  }
  return toBN(value).toNumber();
};
var numberToHex = function numberToHex(value) {
  if (!lodash.isString(value) && !lodash.isNumber(value) && !isBN(value)) {
    throw new Error('value parameter should be a string, number or BigNumber object.');
  }
  if (!isFinite(value) && !isHexStrict(value)) {
    throw new Error("Given input \"".concat(value, "\" is not a number."));
  }
  var number = toBN(value);
  var result = number.toString(16);
  return number.lt(new BN(0)) ? "-0x".concat(result.substr(1)) : "0x".concat(result);
};
var hexToUtf8 = function hexToUtf8(hex) {
  if (!isHexStrict(hex)) {
    throw new Error("The parameter \"".concat(hex, "\" must be a valid HEX string."));
  }
  var string = '';
  var code = 0;
  hex = hex.replace(/^0x/i, '');
  hex = hex.replace(/^(?:00)*/, '');
  hex = hex.split('').reverse().join('');
  hex = hex.replace(/^(?:00)*/, '');
  hex = hex.split('').reverse().join('');
  var l = hex.length;
  for (var i = 0; i < l; i += 2) {
    code = parseInt(hex.substr(i, 2), 16);
    string += String.fromCharCode(code);
  }
  return utf8.decode(string);
};
var hexToAscii = function hexToAscii(hex) {
  if (!isHexStrict(hex)) {
    throw new Error('The parameter must be a valid HEX string.');
  }
  var value = '';
  var i = 0;
  var l = hex.length;
  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }
  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    value += String.fromCharCode(code);
  }
  return value;
};
var utf8ToHex = function utf8ToHex(value) {
  if (!lodash.isString(value)) {
    throw new Error('value parameter should be a string.');
  }
  value = utf8.encode(value);
  var hex = '';
  value = value.replace(/^(?:\u0000)*/, '');
  value = value.split('').reverse().join('');
  value = value.replace(/^(?:\u0000)*/, '');
  value = value.split('').reverse().join('');
  for (var i = 0; i < value.length; i++) {
    var code = value.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? "0".concat(n) : n;
  }
  return "0x".concat(hex);
};
var asciiToHex = function asciiToHex(value) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
  if (!lodash.isString(value)) {
    throw new Error('value parameter should be a string.');
  }
  var hex = '';
  for (var i = 0; i < value.length; i++) {
    var code = value.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? "0".concat(n) : n;
  }
  return '0x' + padRight(hex, length * 2);
};
var hexToBytes = function hexToBytes(hex) {
  if (!lodash.isString(hex)) {
    throw new Error('hex parameter should to be a string.');
  }
  hex = hex.toString(16);
  if (!isHexStrict(hex)) {
    throw new Error("Given value \"".concat(hex, "\" is not a valid hex string."));
  }
  hex = hex.replace(/^0x/i, '');
  hex = hex.length % 2 ? '0' + hex : hex;
  var bytes = [];
  for (var c = 0; c < hex.length; c += 2) {
    bytes.push(parseInt(hex.substr(c, 2), 16));
  }
  return bytes;
};
var bytesToHex = function bytesToHex(bytes) {
  if (!lodash.isArray(bytes)) {
    throw new Error('bytes parameter should to be an array.');
  }
  var hex = [];
  var _iterator = _createForOfIteratorHelper(bytes),
      _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var element = _step.value;
      hex.push((element >>> 4).toString(16));
      hex.push((element & 0xf).toString(16));
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return "0x".concat(hex.join('').replace(/^0+/, ''));
};
var toWei$1 = function toWei$1(number, unit) {
  if (!isBN(number) && !lodash.isString(number)) {
    throw new Error('number parameter should be a string or an BN object to avoid precision errors.');
  }
  if (!lodash.isString(unit)) {
    throw new Error('unit parameter should be a string.');
  }
  var unitValue = getUnitValue(unit);
  return isBN(number) ? toWei(number, unitValue) : toWei(number, unitValue).toString(10);
};
var getUnitValue = function getUnitValue(unit) {
  if (!lodash.isString(unit)) {
    throw new Error('unit parameter should be a string.');
  }
  var unitLowercase = unit ? unit.toLowerCase() : 'ether';
  if (!unitMap[unitLowercase]) {
    throw new Error("This unit \"".concat(unitLowercase, "\" doesn't exist, please use the one of the following units").concat(JSON.stringify(unitMap, null, 2)));
  }
  return unitLowercase;
};
var fromWei$1 = function fromWei$1(number, unit) {
  if (!isBN(number) && !lodash.isString(number)) {
    throw new Error('number parameter should be a string or an BN object to avoid precision errors.');
  }
  if (!lodash.isString(unit)) {
    throw new Error('unit parameter should be a string.');
  }
  var unitValue = getUnitValue(unit);
  return isBN(number) ? fromWei(number, unitValue) : fromWei(number, unitValue).toString(10);
};
var padRight = function padRight(string, chars) {
  var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0';
  if (!lodash.isString(string)) {
    throw new Error('string parameter should be a string.');
  }
  if (!lodash.isNumber(chars)) {
    throw new Error('chars parameter should be a number.');
  }
  if (!lodash.isString(sign)) {
    throw new Error('sign parameter should be a string.');
  }
  var hasPrefix = /^0x/i.test(string) || typeof string === 'number';
  string = string.toString(16).replace(/^0x/i, '');
  var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;
  return (hasPrefix ? '0x' : '') + string + new Array(padding).join(sign || '0');
};
var padLeft = function padLeft(string, chars) {
  var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0';
  if (!lodash.isString(string)) {
    throw new Error('string parameter should be a string.');
  }
  if (!lodash.isNumber(chars)) {
    throw new Error('chars parameter should be a number.');
  }
  if (!lodash.isString(sign)) {
    throw new Error('sign parameter should be a string.');
  }
  var hasPrefix = /^0x/i.test(string) || typeof string === 'number';
  string = string.toString(16).replace(/^0x/i, '');
  var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;
  return (hasPrefix ? '0x' : '') + new Array(padding).join(sign || '0') + string;
};
var toTwosComplement = function toTwosComplement(number) {
  if (!lodash.isNumber(number) && !lodash.isString(number) && !isBN(number)) {
    throw new Error('number parameter should be a number,a string or an BN.');
  }
  return "0x".concat(toBN(number).toTwos(256).toString(16, 64));
};
var getSignatureParameters = function getSignatureParameters(signature) {
  if (!isHexStrict(signature)) {
    throw new Error("Given value \"".concat(signature, "\" is not a valid hex string."));
  }
  if (signature.length < 132) {
    throw new Error('signature has to be at least 132 characters long.');
  }
  var r = signature.slice(0, 66);
  var s = "0x".concat(signature.slice(66, 130));
  var v = "0x".concat(signature.slice(130, 132));
  v = hexToNumber(v);
  if (![27, 28].includes(v)) v += 27;
  return {
    r: r,
    s: s,
    v: v
  };
};
var _elementaryName = function _elementaryName(name) {
  if (!lodash.isString(name)) {
    throw new Error('name parameter should be a string.');
  }
  if (name.startsWith('int[')) {
    return "int256".concat(name.slice(3));
  }
  if (name === 'int') {
    return 'int256';
  }
  if (name.startsWith('uint[')) {
    return "uint256".concat(name.slice(4));
  }
  if (name === 'uint') {
    return 'uint256';
  }
  if (name.startsWith('fixed[')) {
    return "fixed128x128".concat(name.slice(5));
  }
  if (name === 'fixed') {
    return 'fixed128x128';
  }
  if (name.startsWith('ufixed[')) {
    return "ufixed128x128".concat(name.slice(6));
  }
  if (name === 'ufixed') {
    return 'ufixed128x128';
  }
  return name;
};
var _parseTypeN = function _parseTypeN(type) {
  var typesize = /^\D+(\d+).*$/.exec(type);
  return typesize ? parseInt(typesize[1], 10) : null;
};
var _parseTypeNArray = function _parseTypeNArray(type) {
  var arraySize = /^\D+\d*\[(\d+)\]$/.exec(type);
  return arraySize ? parseInt(arraySize[1], 10) : null;
};
var _parseNumber = function _parseNumber(argument) {
  var type = _typeof(argument);
  if (type === 'string') {
    if (isHexStrict(argument)) {
      return new BN(argument.replace(/0x/i, ''), 16);
    } else {
      return new BN(argument, 10);
    }
  } else if (type === 'number') {
    return new BN(argument);
  } else if (isBN(argument)) {
    return argument;
  } else {
    throw new Error("".concat(argument, " is not a number"));
  }
};
var _solidityPack = function _solidityPack(type, value, arraySize) {
  if (!lodash.isString(type)) {
    throw new Error('type parameter should be a string.');
  }
  var size, number;
  type = _elementaryName(type);
  if (type === 'bytes') {
    if (value.replace(/^0x/i, '').length % 2 !== 0) {
      throw new Error("Invalid bytes characters ".concat(value.length));
    }
    return value;
  } else if (type === 'string') {
    return utf8ToHex(value);
  } else if (type === 'bool') {
    return value ? '01' : '00';
  } else if (type.startsWith('address')) {
    if (arraySize) {
      size = 64;
    } else {
      size = 40;
    }
    if (!isAddress(value)) {
      throw new Error("".concat(value, " is not a valid address, or the checksum is invalid."));
    }
    return padLeft(value.toLowerCase(), size);
  }
  size = _parseTypeN(type);
  if (type.startsWith('bytes')) {
    if (!size) {
      throw new Error('bytes[] not yet supported in solidity');
    }
    if (arraySize) {
      size = 32;
    }
    if (size < 1 || size > 32 || size < value.replace(/^0x/i, '').length / 2) {
      throw new Error("Invalid bytes".concat(size, " for ").concat(value));
    }
    return padRight(value, size * 2);
  } else if (type.startsWith('uint')) {
    if (size % 8 || size < 8 || size > 256) {
      throw new Error("Invalid uint".concat(size, " size"));
    }
    number = _parseNumber(value);
    if (number.bitLength() > size) {
      throw new Error("Supplied uint exceeds width: ".concat(size, " vs ").concat(number.bitLength()));
    }
    if (number.lt(new BN(0))) {
      throw new Error("Supplied uint ".concat(number.toString(), " is negative"));
    }
    return size ? padLeft(number.toString('hex'), size / 8 * 2) : number;
  } else if (type.startsWith('int')) {
    if (size % 8 || size < 8 || size > 256) {
      throw new Error("Invalid int".concat(size, " size"));
    }
    number = _parseNumber(value);
    if (number.bitLength() > size) {
      throw new Error("Supplied int exceeds width: ".concat(size, " vs ").concat(number.bitLength()));
    }
    if (number.lt(new BN(0))) {
      return number.toTwos(size).toString('hex');
    } else {
      return size ? padLeft(number.toString('hex'), size / 8 * 2) : number;
    }
  } else {
    throw new Error("Unsupported or invalid type: ".concat(type));
  }
};
var _processSoliditySha3Arguments = function _processSoliditySha3Arguments(argument) {
  if (lodash.isArray(argument)) {
    throw new Error('Autodetection of array types is not supported.');
  }
  var type;
  var value = '';
  var hexArgument, arraySize;
  if (lodash.isObject(argument) && (has(argument, 'v') || has(argument, 't') || has(argument, 'value') || has(argument, 'type'))) {
    type = has(argument, 't') ? argument.t : argument.type;
    value = has(argument, 'v') ? argument.v : argument.value;
  } else {
    type = toHex(argument, true);
    value = toHex(argument);
    if (!type.startsWith('int') && !type.startsWith('uint')) {
      type = 'bytes';
    }
  }
  if ((type.startsWith('int') || type.startsWith('uint')) && typeof value === 'string' && !/^(-)?0x/i.test(value)) {
    value = new BN(value);
  }
  if (lodash.isArray(value)) {
    arraySize = _parseTypeNArray(type);
    if (arraySize && value.length !== arraySize) {
      throw new Error("".concat(type, " is not matching the given array ").concat(JSON.stringify(value)));
    } else {
      arraySize = value.length;
    }
  }
  if (lodash.isArray(value)) {
    hexArgument = value.map(function (value_) {
      return _solidityPack(type, value_, arraySize).toString('hex').replace('0x', '');
    });
    return hexArgument.join('');
  } else {
    hexArgument = _solidityPack(type, value, arraySize);
    return hexArgument.toString('hex').replace('0x', '');
  }
};
var soliditySha3 = function soliditySha3() {
  var arguments_ = Array.prototype.slice.call(arguments);
  var hexArguments = map(arguments_, _processSoliditySha3Arguments);
  return keccak256("0x".concat(hexArguments.join('')));
};

exports.BN = BN;
exports.asciiToHex = asciiToHex;
exports.bytesToHex = bytesToHex;
exports.checkAddressChecksum = checkAddressChecksum;
exports.fromAscii = asciiToHex;
exports.fromDecimal = numberToHex;
exports.fromUtf8 = utf8ToHex;
exports.fromWei = fromWei$1;
exports.getSignatureParameters = getSignatureParameters;
exports.hexToAscii = hexToAscii;
exports.hexToBytes = hexToBytes;
exports.hexToNumber = hexToNumber;
exports.hexToNumberString = hexToNumberString;
exports.hexToString = hexToUtf8;
exports.hexToUtf8 = hexToUtf8;
exports.isAddress = isAddress;
exports.isBN = isBN;
exports.isHex = isHex;
exports.isHexStrict = isHexStrict;
exports.jsonInterfaceMethodToString = jsonInterfaceMethodToString;
exports.keccak256 = keccak256;
exports.leftPad = padLeft;
exports.numberToHex = numberToHex;
exports.padLeft = padLeft;
exports.padRight = padRight;
exports.randomHex = randomHex;
exports.rightPad = padRight;
exports.sha3 = keccak256;
exports.soliditySha3 = soliditySha3;
exports.stringToHex = utf8ToHex;
exports.stripHexPrefix = stripHexPrefix;
exports.toAscii = hexToAscii;
exports.toBN = toBN;
exports.toChecksumAddress = toChecksumAddress;
exports.toDecimal = hexToNumber;
exports.toHex = toHex;
exports.toTwosComplement = toTwosComplement;
exports.toUtf8 = hexToUtf8;
exports.toWei = toWei$1;
exports.unitMap = unitMap$1;
exports.utf8ToHex = utf8ToHex;
